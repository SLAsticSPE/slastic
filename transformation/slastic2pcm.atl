-- @path Slastic=/Slastic2Pcm/model/slastic.ecore
-- @path Pcm=/Slastic2Pcm/model/pcm.ecore

module slastic2pcm;
create 
	RESOURCETYPE: Pcm,
	REPOSITORY: Pcm,
	RESOURCEENVIRONMENT: Pcm, 
	ALLOCATION: Pcm,
	SYSTEM: Pcm
from 
	IN: Slastic, 
	USAGE: Slastic;

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

helper def: getUsageModel: Slastic!UsageModel = 
	Slastic!UsageModel.allInstances()->asSequence()->first();

--------------------------------------------------------------------------------
-- Create ResourceRepository
--------------------------------------------------------------------------------

rule InitializeResourceRepository() {
	to tgt: Pcm!ResourceRepository in RESOURCETYPE (
		availableResourceTypes_ResourceRepository <- Sequence{
			thisModule.NewProcessingResourceType('CPU','_oro4gG3fEdy4YaaT-RYrLQ'),
			thisModule.NewProcessingResourceType('HDD','_BIjHoQ3KEdyouMqirZIhzQ'),
			thisModule.NewProcessingResourceType('DELAY', '_nvHX4KkREdyEA_b89s7q9w'),
			thisModule.NewCommunicationLinkResourceType('LAN', '_o3sScH2AEdyH8uerKnHYug')
		}
	)
}

rule NewProcessingResourceType(name: String, id: String){
	to tgt: Pcm!ProcessingResourceType in RESOURCETYPE (
		entityName <- name,
		id <- id
	) do { tgt; }
}

rule NewCommunicationLinkResourceType(name: String, id: String){
	to tgt: Pcm!CommunicationLinkResourceType in RESOURCETYPE (
		entityName <- name,
		id <- id
	) do { tgt; }
}

--------------------------------------------------------------------------------
-- Transform typeRepositoryModel to RepositoryModel
--------------------------------------------------------------------------------

rule NewInterface(componentType: Slastic!ComponentType) {
	to tgt: Pcm!Interface in REPOSITORY (
		id <- 'i' + componentType.id.toString(),
		entityName <- 'I' + componentType.name,
		signatures__Interface <- componentType.operations->collect(operation | 
			operation.signature
		)
	) 
	do {
		tgt;
	}
}

rule NewProvidedRole(interface: Pcm!Interface, componentType: Slastic!ComponentType) {
	to tgt: Pcm!ProvidedRole in REPOSITORY (
		entityName <- 'Provided_' + interface.entityName + '_' + componentType.name,
		providedInterface__ProvidedRole <- interface
	)
	do {
		tgt;
	}
}

rule NewRequiredRole(interface: Slastic!Interface) {
	to tgt: Pcm!RequiredRole in REPOSITORY (
		entityName <- interface.name
	)
	do {
		tgt;
	}
}

rule NewParameter(name: String) {
	to tgt: Pcm!Parameter in REPOSITORY (
		parameterName <- name
	) 
	do {
		tgt;
	}
}

rule TypeRepositoryModelToRepository {
	from src: Slastic!TypeRepositoryModel
	to tgt: Pcm!Repository in REPOSITORY (
		id <- '1',
		entityName <- 'defaultRepository',
		-- Create dummy interfaces.
		interfaces__Repository <- src.componentTypes->collect(component | 
			thisModule.NewInterface(component)
		),
		components__Repository <- src.componentTypes
	)
}

rule ComponentTypeToBasicComponent {
	from src: Slastic!ComponentType
	to tgt: Pcm!BasicComponent in REPOSITORY (
		id <- src.id.toString(),
		entityName <- src.name,
		providedRoles_InterfaceProvidingEntity <- thisModule.NewProvidedRole(
			tgt.repository_ProvidesComponentType.interfaces__Repository->any(interface | 
				interface.id = 'i' + src.id.toString() 
			),
			src
		),
		requiredRoles_InterfaceRequiringEntity <- src.requiredInterfaces->collect(interface | 
			thisModule.NewRequiredRole(interface)
		),
		serviceEffectSpecifications__BasicComponent <- src.operations->collect(operation | 
			thisModule.NewResourceDemandingSEFF(operation)
		)
	)
}

rule SignatureToSignature {
	from src: Slastic!Signature
	to tgt: Pcm!Signature in REPOSITORY (
		serviceName <- src.name,
		parameters__Signature <- src.paramTypes->collect(paramType | 
			thisModule.NewParameter(paramType)
		)
	)
}

lazy rule NewResourceDemandingSEFF {
	from src: Slastic!Operation
	using {
		usageModel: Slastic!UsageModel = thisModule.getUsageModel;
		callingRelationships: Sequence(Slastic!CallingRelationship) = usageModel.callingRelationships->select(relationship | 
			relationship.callingOperation = src
		);
		start: Pcm!AbstractAction = thisModule.NewStartAction();
		loopSequence: Sequence(Pcm!AbstractAction) = Sequence{start};
	}
	to tgt: Pcm!ResourceDemandingSEFF in REPOSITORY (
		describedService__SEFF <- src.signature,
		id <- src.id.toString(),
		steps_Behaviour <- 
			loopSequence.append(
				callingRelationships->collect(relationship |
					thisModule.NewLoopBehaviour(relationship)
				)
			).append(thisModule.NewStopAction(loopSequence.last()))
	)
	-- Link the elements of the loop sequence.
	do {
		for (elem in tgt.steps_Behaviour.subSequence(2, tgt.steps_Behaviour.size())) {
			elem.refSetValue('predecessor_AbstractAction', tgt.steps_Behaviour.at(tgt.steps_Behaviour.indexOf(elem) - 1));
		}
	}
}

lazy rule NewLoopBehaviour {
	from relationship: Slastic!CallingRelationship
	to tgt: Pcm!LoopAction in REPOSITORY (
		bodyBehaviour_Loop <- thisModule.NewLoopBody(relationship),
		iterationCount_LoopAction <- thisModule.NewPmfFromFrequencyDistribution(relationship.frequencyDistribution)
	)
}

lazy rule NewLoopBody {
	from src: Slastic!CallingRelationship
	using {
		start: Pcm!StartAction = thisModule.NewStartAction();
		eca: Pcm!ExternalCallAction = thisModule.NewExternalCallAction(start, src.calledSignature);
		stop: Pcm!StopAction = thisModule.NewStopAction(eca);
	}
	to tgt: Pcm!ResourceDemandingBehaviour in REPOSITORY (
		steps_Behaviour <- Sequence {
			start, eca, stop
		}
	)
}

rule NewStartAction() {
	to tgt: Pcm!StartAction in REPOSITORY (
		
	)
	do {
		tgt;
	}
}

rule NewStopAction(predecessor: Pcm!AbstractAction) {
	to tgt: Pcm!StopAction in REPOSITORY (
		predecessor_AbstractAction <- predecessor
	)
	do {
		tgt;
	}
}

rule NewExternalCallAction(predecessor: Pcm!AbstractAction, signature: Slastic!Signature) {
	to tgt: Pcm!ExternalCallAction in REPOSITORY (
		predecessor_AbstractAction <- predecessor,
		calledService_ExternalService <- signature
	)
	do {
		tgt;
	}
}

lazy rule NewPmfFromFrequencyDistribution {
	from src: Slastic!FrequencyDistribution
	using {
		callCount: Real = src.frequencies->iterate(e; res: Real = 0 |
			res + e
		);
		relativeFrequencies: Sequence(Real) = src.frequencies->iterate(e; res: Sequence(Real) = Sequence{} |
			res.append((1/callCount)*e)
			-- (1/callCount)*e means e/callCount, which doesn't work with atl's type system.
		);
		pmfs: Sequence(Sequence(Integer)) = 
			src.values->iterate(e; res : Sequence(Integer) = Sequence{} |
				res.append(Sequence{e,relativeFrequencies->at(res.size() + 1)})
			-- Using the size of the result as an iteration counter for the list of relative frequencies.
		);
		pmfString: String = 
			'IntPMF[' + 
			pmfs->iterate(pmf; output: String = '' |
				output + '(' + pmf.at(1) + ';' + (pmf.at(2)) + ')'
		) + ']';
	}
	to tgt: Pcm!PCMRandomVariable in REPOSITORY (
		specification <- pmfString
	)
}

--------------------------------------------------------------------------------
-- Transform executionEnvironmentModel to ResourceEnvironmentModel
--------------------------------------------------------------------------------

rule ExecutionEnvironmentModelToResourceEnvironment {
	from src: Slastic!ExecutionEnvironmentModel
	to tgt: Pcm!ResourceEnvironment  in RESOURCEENVIRONMENT (
		resourceContainer_ResourceEnvironment <- src.executionContainers
	)
	do {
		-- TODO Resource repository should be dynamically loaded, instead of being created with fixed parameters.
		thisModule.InitializeResourceRepository();
	}
}

rule ExecutionContainerToResourceContainer {
	from src: Slastic!ExecutionContainer
	to tgt: Pcm!ResourceContainer  in RESOURCEENVIRONMENT (
		id <- src.id.toString(),
		entityName <- src.name,
		activeResourceSpecifications_ResourceContainer <- src.executionContainerType.resources
	)
}

rule ResourceSpecificationToProcessingResourceSpecification {
	from src: Slastic!ResourceSpecification
	to tgt: Pcm!ProcessingResourceSpecification in RESOURCEENVIRONMENT (
		-- TODO Support resource types other than cpu resources.
		activeResourceType_ActiveResourceSpecification <- 
		if src.resourceType.name = 'CPU_RESOURCE_TYPE'
			then Pcm!ProcessingResourceType.allInstances()->any(type | type.id = '_oro4gG3fEdy4YaaT-RYrLQ')
			else OclUndefined
		endif
	)
}

--------------------------------------------------------------------------------
-- Transform componentAssemblyModel to SystemModel
--------------------------------------------------------------------------------
rule NewProvidedRoleFromComponent(component: Pcm!BasicComponent, interface: Pcm!Interface) {
	to tgt: Pcm!ProvidedRole in SYSTEM(
		id <- 'p' + interface.id,
		entityName <- 'Provided_' + interface.entityName,
		providedInterface__ProvidedRole <- component.providedRoles_InterfaceProvidingEntity.first()
	) do { tgt; }
}

rule NewProvidedDelegationConnector() {
	to tgt: Pcm!ProvidedDelegationConnector in SYSTEM (
		
	)
}

rule ComponentAssemblyModelToSystem {
	from src: Slastic!ComponentAssemblyModel
	to tgt: Pcm!System in SYSTEM (
		id <- '1',
		entityName <- 'defaultSystem',
		childComponentContexts_ComposedStructure <- src.assemblyComponents,
		compositeAssemblyConnectors_ComposedStructure <- src.assemblyConnectors,
		providedRoles_InterfaceProvidingEntity <- Pcm!BasicComponent.allInstances()->collect(component | 
			component.providedRoles_InterfaceProvidingEntity).flatten()->collect(providedRole | 
				thisModule.NewProvidedRoleFromComponent(providedRole.providingEntity_ProvidedRole, providedRole.providedInterface__ProvidedRole))
	)
}

rule AssemblyComponentToAssemblyContext {
	from src: Slastic!AssemblyComponent
	to tgt: Pcm!AssemblyContext in SYSTEM (
		id <- src.id.toString(),
		entityName <- 'Assembly_' + src.name,
		encapsulatedComponent_ChildComponentContext <- src.componentType
	)
}

rule AssemblyConnectorToAssemblyConnector {
	from src: Slastic!AssemblyConnector
	to tgt: Pcm!AssemblyConnector in SYSTEM (
		
	)
}

--------------------------------------------------------------------------------
-- Transform componentDeploymentModel to AllocationModel
--------------------------------------------------------------------------------

rule ComponentDeploymentModelToAllocation {
	from src: Slastic!ComponentDeploymentModel
	to tgt: Pcm!Allocation in ALLOCATION (
		id <- '1',
		allocationContexts_Allocation <- src.deploymentComponents
	)
}

rule DeploymentComponentToAllocationContext {
	from src: Slastic!DeploymentComponent
	to tgt: Pcm!AllocationContext in ALLOCATION (
		id <- src.id.toString(),
		entityName <- 'Allocation_' + Pcm!AssemblyContext.allInstances()->
			any(acontext | acontext.id = src.assemblyComponent.id.toString()).entityName,
		resourceContainer_AllocationContext <- Pcm!ResourceContainer.allInstances()->
			any(container | container.id = src.executionContainer.id.toString()),
		assemblyContext_AllocationContext <-Pcm!AssemblyContext.allInstances()->
			any(acontext | acontext.id = src.assemblyComponent.id.toString())
	)
}